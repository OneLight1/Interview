JUC（java.util.concurrent）
        进程和线程
            进程：后台运行的程序（我们打开的一个软件，就是进程）
            线程：轻量级的进程，并且一个进程包含多个线程（同在一个软件内，同时运行窗口，就是线程）
        并发和并行
            并发：同时访问某个东西，就是并发
            并行：一起做某些事情，就是并行
JUC下的三个包
        java.util.concurrent
            java.util.concurrent.atomic
            java.util.concurrent.locks

谈谈对Volatile的理解

Volatile在日常的单线程环境是应用不到的

    Volatile是Java虚拟机提供的轻量级的同步机制（三大特性）
        保证可见性
        不保证原子性
        禁止指令重排

JMM是什么
    JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，
    通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式

JMM关于同步的规定：
    线程解锁前，必须把共享变量的值刷新回主内存
    线程解锁前，必须读取主内存的最新值，到自己的工作内存
    加锁和解锁是同一把锁

  由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，
  而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作
  内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中
  的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过
  主内存来完成，其简要访问过程：
  
  插入JMM图片。。。。。
  
以上涉及两个概念：
   主内存：  Java堆内存
   工作内存：Java栈内存
   
JMM的特性

JMM的三大特性，volatile只保证了两个，即可见性和有序性，不满足原子性
    可见性
    原子性
    有序性

可见性代码验证

但我们对于成员变量没有添加任何修饰时，是无法感知其它线程修改后的值

